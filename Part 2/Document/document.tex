\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{color, colortbl}
\definecolor{Highlight}{rgb}{0.3, 0.76, 0.97}
\author{Hein van Beers \qquad Student number: 0765658 \\{\tt h.a.v.beers@student.tue.nl}\\ \\ Jeroen van Hoof \qquad Student number: 0778486 \\{\tt j.m.a.p.v.hoof@student.tue.nl}}
\title{Automated Reasoning\\
	 \large Practical assignment, Part II}
\begin{document}
	\maketitle
	
	\section*{Problem 1: Non-self-supporting Villages}
	Three non-self-supporting villages A, B and C in the middle of nowhere consume one food package each per time unit. The required food packages are delivered by a truck, having a capacity of 300 food packages. The locations of the villages are given, together with the number of time units it takes the truck to travel from one village to another, including loading or delivering. The truck has to pick up its food packages at location S containing an unbounded supply. The villages only have a limited capacity to store food packages: for A and B this capacity is 120, for C it is 200.
	
	\subsection*{Solution:}
	We generalize this problem to $n$ villages and a truck capacity of $C$. We also have a variable $m$ which represents the amount of steps we perform in the model. Each step corresponds to a change in the position of the truck. For each village we then introduce $n * (m+2)$ integer variables $v_{i\_j}$ for $i=1,...,n$ and $j=0,...,m+1$, where $i$ indicates the number of each village and $j$ is the number of steps that have been performed. So now we have a variable $v_{i\_j}$ that represents the amount of food packages in village $i$ after $j$ steps have been performed. Next, we also introduce $m+2$ integer variables $p_j$, $t_j$ and $d_j$ for $j=0,...,m+1$, where $p_j$ represents the position of the truck after $j$ number of steps have been performed, $t_j$ represents the load of the truck after $j$ number of steps have been performed, and $d_j$ represents the amount of food packages that are being delivered at step $j$.\\
	
	Since for each village $i$ the food capacity $v_{i\_j}$ may not exceed its maximum capacity $max_i$, neither may get below zero for any step $j$, we introduce the following formula
\[ \bigwedge_{j=0}^{m+1} \bigwedge_{i=1}^n (v_{i\_j} >= 0) \wedge (v_{i\_j} <= max_i).\]
Where $max_i$ is the maximum capacity of village $i$. In the table below you can see the maximum capacities of villages A, B and C, together with their corresponding integer values.

\begin{table}[H]
\centering
\caption{Maximum capacities of each village}
\label{my-label}
\begin{tabular}{c|c|c}
\textbf{Village} & \textbf{Corresponding $i$} & \textbf{Maximum capacity} \\ \hline
A	&	1	&	120\\ \hline
B	&	2	&	120\\ \hline
C	&	3	&	200
\end{tabular}
\end{table}

	The position $p_j$ of the truck at each step $j$ should be bounded below by zero and above by the number of villages we have in total. Also the capacity of the truck $t_j$ at each step $j$ should be bounded below by zero and above by the maximum capacity of the truck $C$. Finally, we also need a bound on the capacity that is being delivered $d_j$ at each step $j$, since we can never deliver a negative value. The bounds for these three variables can be represented with the following formula
	\[ \bigwedge_{j=0}^{m+1} (p_j >= 0) \wedge (p_j <= n) \wedge (t_j >= 0) \wedge (t_j <= C) \wedge (d_j >= 0).\]
	Where $m$ is the amount of steps we take, $n$ is the total number of villages (in our case 3), and $C$ is the maximum capacity of the truck.\\

Finally, we need to implement the steps that can be taken at each step of the model. The steps that can be taken depend on the current position of the truck, since in the next step, the truck can only go to neighbouring villages. So let $X_i$ be the set of neighbouring villages of village $i$ and let $f_i(x)$ be a function that determines the costs of going from village $i$ to village $x$. We now can easily express the steps and their corresponding changes in the variables. Since each step contains several variables that need to be updated, we will first give the different parts of the entire formula and explain them. Finally, we will give the entire formula.\\

As said before, the variables of the (immediate) next step depend on the current position of the truck. This is why we have a case distinction on each position in time $p_j$ of the truck. The formula below represents the possibilities for step $j$ and current position $0$
\[ (p_j = i) \Rightarrow \cdots \]
Where $i \in {0,...,n}$ represents the position of the truck at step $j$.\\

Next, we need to define what happens when we know the position of the truck at step $j$, this is what comes after the implication mentioned above. The first thing we observe is the amount of food packages that the truck delivers at step $j$. When the truck is at the supply stack (position 0), we do not deliver anything. This can be represented by the following formula

\[ \cdots ( (d_j = 0) \wedge \cdots \]

But when the truck is at a village, we can deliver any amount of food packages, as long as the current capacity of the village plus the amount we deliver does not exceed the total capacity of that village. So the amount that we deliver to the village should be less than or equal to the maximum capacity of the village minus the current capacity of that village. This can be represented by the following formula

\[ \cdots ( (d_j \leq max(i) - v_{i\_j}) \wedge \cdots \]

After this, we need to define what our next steps can be and what the consequences of taking a specific step are. This can be done by looking at the neighbouring villages of the current position of the truck. If we are at position $i$, then the neighbouring villages of position $i$ are given by the set $X_i$. For the case that the truck is currently at the supply stack (position 0), we again have a special case. Since now the capacity of each village only needs to be reduced in the next step. This needs to be done for each neighbouring village of the current position. This is represented by the following formula

\[ \cdots (\bigvee_{x \in X_0} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (v_{y\_j+1} = v_{y\_j} - f_0(x))) \wedge \cdots \]
Where $x$ indicates the village we can choose next, $y$ indicates all villages, since their supply needs to be reduced, and $f_0(x)$ indicates the amount of time it costs from going from position 0 to village $x$.

When the truck is currently at a village, we can also deliver to that village. So in that case, the supply of that specific village not only gets reduced, but also gets increased again by the amount of food packages we deliver. This can be represented by the following formula

\[ \cdots (\bigvee_{x \in X_i} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \cdots \]
Where $x$ indicates the village we can choose next, $y$ indicates all villages, since their supply needs to be reduced, and $f_i(x)$ indicates the amount of time it costs from going from position $i$ to position $x$. We see a distinction between the case that the village from which we are updating the supply is the same as the village we are currently in ($y=i$) and all the other cases ($y \neq i$). When $y=i$ we also add the amount of food packages that we deliver in that step $d_j$ to the supply of that village. The other cases only get their supply being reduced as in the case described above for position 0.

Finally, we also need to set the load of the truck, since this also changes each step. The value of the truck also depends on the village we choose for the next step, since when we are at the supply stack in the next step, we do not deliver anything, but we can increase the load of our truck in that position. In all the other positions, we only can reduce the load of the truck. So we again have a case distinction. When the next position we choose is equal to position 0 ($p_{j+1} = 0$), we get the following formula

\[ \cdots ((p_j{j+1} = 0) \wedge (t_{j+1} \geq t_j))))).\]

When the next position is not the supply stack ($p_{j+1} \neq 0$), we need to reduce the load of the truck by the amount we deliver in that step. This can be represented by the following formula

\[ \cdots ((p_{j+1} \neq 0) \wedge (t_{j+1} = t_j - d_{j+1}))))).\]

So the entire formula for the case that the truck is currently at the supply stack is given below
\[ (p_j = 0) \Rightarrow ( (d_j = 0) \wedge \]
\[ (\bigvee_{x \in X_0} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (v_{y\_j+1} = v_{y\_j} - f_0(x))) \wedge \]
\[ (t_{j+1} = t_j - d_{j+1})))).\]

Similarly, we can also do this for all other positions $i$, but then we only need to add that the delivery changes and that the capacity of the villages also changes if the truck delivers to its village. We can see the possibilities for step $j$ and current position $i \neq 0$ in the formula below

\[ (p_j = i) \Rightarrow ( (d_j \leq max(i) - v_{i\_j}) \wedge \]
\[ (\bigvee_{x \in X_i} ((p_{j+1} = 0) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(y) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \]
\[ (t_{j+1} \geq t_j)) \vee ((p_{j+1} \neq 0) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(y) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \]
\[ (t_{j+1} = t_j - d_{j+1})))).\]

This formula is quite big and looks impressive, but can easily be expressed in SMT syntax, for instance, for $n=3$, $m=20$ and the connections between the villages are as described in the assignment, one can generate the following SMT code\\

{\footnotesize

{\tt (benchmark Assignment1.smt}

{\tt :logic QF\_UFLIA}

{\tt :extrafuns (}

{\tt (v1\_0 Int) (v2\_0 Int) (v3\_0 Int) }

{\tt (v1\_1 Int) (v2\_1 Int) (v3\_1 Int) }

{\tt (v1\_2 Int) (v2\_2 Int) (v3\_2 Int) }

$\cdots \cdots$

{\tt (p\_0 Int) (t\_0 Int) (d\_0 Int) }

{\tt (p\_1 Int) (t\_1 Int) (d\_1 Int) }

{\tt (p\_2 Int) (t\_2 Int) (d\_2 Int) }

$\cdots \cdots$

{\tt )}

{\tt :formula}

{\tt   (and}

{\tt ;Initialization of variables }

{\tt (= p\_0 0) (= v1\_0 40) (= v2\_0 30) (= v3\_0 145) (= t\_0 300) }

{\tt ;Setting the bounds of the variables }

{\tt (>= v1\_0 0) (<= v1\_0 120) (>= v2\_0 0) (<= v2\_0 120) (>= v3\_0 0) (<= v3\_0 200) }

{\tt (>= v1\_1 0) (<= v1\_1 120) (>= v2\_1 0) (<= v2\_1 120) (>= v3\_1 0) (<= v3\_1 200) }

{\tt (>= v1\_2 0) (<= v1\_2 120) (>= v2\_2 0) (<= v2\_2 120) (>= v3\_2 0) (<= v3\_2 200) }

$\cdots \cdots$

{\tt (>= p\_0 0) (<= p\_0 3) (>= t\_0 0) (<= t\_0 300) (>= d\_0 0) }

{\tt (>= p\_1 0) (<= p\_1 3) (>= t\_1 0) (<= t\_1 300) (>= d\_1 0) }

{\tt (>= p\_2 0) (<= p\_2 3) (>= t\_2 0) (<= t\_2 300) (>= d\_2 0) }

$\cdots \cdots$

{\tt ;Taking the first step in the model }\\

{\tt ;If the current position is equal to the supply stack }

{\tt (implies (= p\_0 0) (and (= d\_0 0) }

{\tt          (or (and (= p\_1 1) (= v1\_1 (- v1\_0 29)) (= v2\_1 (- v2\_0 29)) (= v3\_1 (- v3\_0 29)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 2) (= v1\_1 (- v1\_0 21)) (= v2\_1 (- v2\_0 21)) (= v3\_1 (- v3\_0 21)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village A }

{\tt (implies (= p\_0 1) (and (<= d\_0 (- 120 v1\_0)) }

{\tt          (or (and (= p\_1 0) (= v1\_1 (- (+ v1\_0 d\_0) 29)) (= v2\_1 (- v2\_0 29)) (= v3\_1 (- v3\_0 29)) (>= t\_1 t\_0)) }

{\tt              (and (= p\_1 2) (= v1\_1 (- (+ v1\_0 d\_0) 17)) (= v2\_1 (- v2\_0 17)) (= v3\_1 (- v3\_0 17)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 3) (= v1\_1 (- (+ v1\_0 d\_0) 32)) (= v2\_1 (- v2\_0 32)) (= v3\_1 (- v3\_0 32)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village B }

{\tt (implies (= p\_0 2) (and (<= d\_0 (- 120 v2\_0)) }

{\tt          (or (and (= p\_1 0) (= v1\_1 (- v1\_0 21)) (= v2\_1 (- (+ v2\_0 d\_0) 21)) (= v3\_1 (- v3\_0 21)) (>= t\_1 t\_0)) }

{\tt              (and (= p\_1 1) (= v1\_1 (- v1\_0 17)) (= v2\_1 (- (+ v2\_0 d\_0) 17)) (= v3\_1 (- v3\_0 17)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 3) (= v1\_1 (- v1\_0 37)) (= v2\_1 (- (+ v2\_0 d\_0) 37)) (= v3\_1 (- v3\_0 37)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village C }

{\tt (implies (= p\_0 3) (and (<= d\_0 (- 200 v3\_0)) }

{\tt          (or (and (= p\_1 1) (= v1\_1 (- v1\_0 32)) (= v2\_1 (- v2\_0 32)) (= v3\_1 (- (+ v3\_0 d\_0) 32)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 2) (= v1\_1 (- v1\_0 37)) (= v2\_1 (- v2\_0 37)) (= v3\_1 (- (+ v3\_0 d\_0) 37)) (= t\_1 (- t\_0 d\_1)))))) }

$\cdots \cdots$

{\tt )) }
}

	\subsection*{Problem 1a}
	We need to show that it is impossible to deliver food packages in such a way that each of the villages consumes one food package per time unit forever. In order to show that this is impossible, we need to find a value for the amount of steps $m$, for which one or more villages have a shortage of food packages. We just tried several cases for $m$ and discovered that with $m=20$ we can still deliver food packages, without any village coming into trouble. But with $m=21$ we see that \texttt{yices} returns \texttt{unsat}, which means that it is not possible to deliver packages for more than 20 steps and therefore also not forever. Table \ref{tab:1a} shows the steps for $m=20$ and which does not yet result in a shortage of food, while any step after step 20 will result in a food shortage.
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			step & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 300 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 189 & 111 & 19 & 9 & 124\tabularnewline
			2 & 1 & 71 & 118 & 2 & 103 & 107\tabularnewline
			3 & 0 & 300 & 0 & 91 & 74 & 78\tabularnewline
			4 & 2 & 234 & 66 & 70 & 53 & 57\tabularnewline
			5 & 3 & 66 & 168 & 33 & 82 & 20\tabularnewline
			6 & 1 & 0 & 66 & 1 & 50 & 156\tabularnewline
			7 & 0 & 300 & 0 & 38 & 21 & 127\tabularnewline
			8 & 2 & 180 & 120 & 17 & 0 & 106\tabularnewline
			9 & 1 & 60 & 120 & 0 & 103 & 89\tabularnewline
			10 & 0 & 300 & 0 & 91 & 74 & 60\tabularnewline
			11 & 2 & 233 & 67 & 70 & 53 & 39\tabularnewline
			12 & 3 & 70 & 163 & 33 & 83 & 2\tabularnewline
			13 & 1 & 4 & 66 & 1 & 51 & 133\tabularnewline
			14 & 0 & 296 & 0 & 38 & 22 & 104\tabularnewline
			15 & 2 & 179 & 117 & 17 & 1 & 83\tabularnewline
			16 & 1 & 64 & 115 & 0 & 101 & 66\tabularnewline
			17 & 3 & 15 & 49 & 83 & 69 & 34\tabularnewline
			18 & 1 & 15 & 0 & 51 & 37 & 51\tabularnewline
			19 & 2 & 1 & 14 & 34 & 20 & 34\tabularnewline
			20 & 1 & 1 & 0 & 17 & 17 & 17\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{20 steps, 300 truck capacity}
		\label{tab:1a}
	\end{table}
		
	\subsection*{Problem 1b}
	%Als er een loop is en we vinden binnen aantal stappen een en in die loop is het mogelijk om te blijven deliveren en je komt in precies dezelfde states weer terug, dan kunnen we oneindig doorgaan.
	For this question we need to show that with a truck capacity of 320 food packages, it is possible to deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	To solve problems \textbf{b} and \textbf{c}, we need to find a loop that includes a finite amount of legal states. Once we find such a loop, we can repeat it infinitely, and conclude that it is possible to deliver food packages in such a way that each of the villages consumes one food package per time unit forever.\\
	
	A loop is defined as a set of succeeding states with a first state $S_i$ and last state $S_j$, where $S_i$ and $S_j$ are similar and $j > i$.
	
	Take two states $i$ and $j$, and take $n$ as the number of villages. Then two states are similar if and only if:
	$$similar(i, j) \Leftrightarrow p_i = p_j \wedge t_i = t_j \wedge \forall (k: 1 \leq k \leq n : v_{k\_i} = v_{k\_j})$$
	
	So, if we take $m$ as the number of steps, a solution that holds a loop, can be defined with:
	%$$\exists (i, j: 0 \leq i,j \leq m \wedge j > i: similar(i, j))$$
	
	$$\bigvee_{i, j}^m j > i \wedge similar(i, j)$$
	
	We define a loop in smt as follows. For all $0 \leq i, j \leq m$ with $j > i$ we have {\tt (= p\_$i$ p\_$j$) (= t\_$i$ t\_$j$)}, and for each village $n$, we have: {\tt (= v$n$\_$i$ v$n$\_$j$)}. We then include this code together with the original code from the previous part of this assignment and when we run the program with $m=25$ and a truck capacity of 320, we get the result that is shown in Table \ref{tab:1b}.\\
	
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			s & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 320 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 281 & 39 & 19 & 9 & 124\tabularnewline
			2 & 1 & 163 & 118 & 2 & 31 & 107\tabularnewline
			3 & 2 & 57 & 106 & 103 & 14 & 90\tabularnewline
			4 & 0 & 319 & 0 & 82 & 99 & 69\tabularnewline
			5 & 1 & 253 & 66 & 53 & 70 & 40\tabularnewline
			6 & 3 & 66 & 187 & 87 & 38 & 8\tabularnewline
			7 & 2 & 0 & 66 & 50 & 1 & 158\tabularnewline
			\rowcolor{Highlight}
			8 & 0 & 271 & 0 & 29 & 46 & 137\tabularnewline
			9 & 1 & 151 & 120 & 0 & 17 & 108\tabularnewline
			10 & 2 & 32 & 119 & 103 & 0 & 91\tabularnewline
			11 & 0 & 319 & 0 & 82 & 98 & 70\tabularnewline
			12 & 1 & 253 & 66 & 53 & 69 & 41\tabularnewline
			13 & 3 & 67 & 186 & 87 & 37 & 9\tabularnewline
			14 & 2 & 0 & 67 & 50 & 0 & 158\tabularnewline
			\rowcolor{Highlight}
			15 & 0 & 271 & 0 & 29 & 46 & 137\tabularnewline
			16 & 1 & 151 & 120 & 0 & 17 & 108\tabularnewline
			17 & 2 & 32 & 119 & 103 & 0 & 91\tabularnewline
			18 & 0 & 320 & 0 & 82 & 98 & 70\tabularnewline
			19 & 1 & 280 & 40 & 53 & 69 & 41\tabularnewline
			20 & 3 & 155 & 125 & 61 & 37 & 9\tabularnewline
			21 & 2 & 110 & 45 & 24 & 0 & 97\tabularnewline
			22 & 1 & 36 & 74 & 7 & 28 & 80\tabularnewline
			23 & 2 & 0 & 36 & 64 & 11 & 63\tabularnewline
			24 & 0 & 16 & 0 & 43 & 26 & 42\tabularnewline
			25 & 2 & 0 & 16 & 22 & 5 & 21\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{25 steps, 320 truck capacity}
		\label{tab:1b}
	\end{table}
	
	This table shows that step 8 and step 15 are exactly the same and therefore we have a loop from step 8 to step 15. We also see that we can reach state 15 from the initial state without any village going below zero food packages. This means that we can reach state 15 and then continue with state 9 again, then 10, etc. without ever having any village with a shortage of food packages. So from this we can conclude that it is possible to deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	\subsection*{Problem 1c}
	Finally, we also need to check the same as for question 1b, but now with a truck capacity of 318 food packages. Table \ref{tab:1c} shows that step 5 and step 25 are exactly the same (what we deliver in the step does not have to be the same) and we can reach step 25 without having any village with a shortage of food packages. So this implies that with a truck capacity of 318 food packages, we can also deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			s & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 318 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 207 & 111 & 19 & 9 & 124\tabularnewline
			2 & 1 & 89 & 118 & 2 & 103 & 107\tabularnewline
			3 & 0 & 314 & 0 & 91 & 74 & 78\tabularnewline
			4 & 2 & 247 & 67 & 70 & 53 & 57\tabularnewline
			\rowcolor{Highlight}
			5 & 3 & 68 & 179 & 33 & 83 & 20\tabularnewline
			6 & 1 & 2 & 66 & 1 & 51 & 167\tabularnewline
			7 & 0 & 299 & 0 & 38 & 22 & 138\tabularnewline
			8 & 2 & 241 & 58 & 17 & 1 & 117\tabularnewline
			9 & 1 & 121 & 120 & 0 & 42 & 100\tabularnewline
			10 & 2 & 26 & 95 & 103 & 25 & 83\tabularnewline
			11 & 0 & 318 & 0 & 82 & 99 & 62\tabularnewline
			12 & 1 & 252 & 66 & 53 & 70 & 33\tabularnewline
			13 & 3 & 67 & 185 & 87 & 38 & 1\tabularnewline
			14 & 2 & 0 & 67 & 50 & 1 & 149\tabularnewline
			15 & 0 & 219 & 0 & 29 & 47 & 128\tabularnewline
			16 & 1 & 118 & 101 & 0 & 18 & 99\tabularnewline
			17 & 2 & 0 & 118 & 84 & 1 & 82\tabularnewline
			18 & 0 & 317 & 0 & 63 & 98 & 61\tabularnewline
			19 & 1 & 232 & 85 & 34 & 69 & 32\tabularnewline
			20 & 3 & 71 & 161 & 87 & 37 & 0\tabularnewline
			21 & 2 & 4 & 67 & 50 & 0 & 124\tabularnewline
			22 & 0 & 287 & 0 & 29 & 46 & 103\tabularnewline
			23 & 1 & 200 & 87 & 0 & 17 & 74\tabularnewline
			24 & 2 & 80 & 120 & 70 & 0 & 57\tabularnewline
			\rowcolor{Highlight}
			25 & 3 & 68 & 12 & 33 & 83 & 20\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{25 steps, 318 truck capacity}
		\label{tab:1c}
	\end{table}

{\bf Remark:}
We did not set the load of the truck to be equal to its maximum capacity, each time the truck comes at the supply stack, so the program can choose how much it wants to fill the truck. But if we would do this and set it to the maximum truck capacity, the program would probably be a little bit faster and therefore, more efficient. So this could be added as an improvement to our program.\\

{\bf Generalization:} 
As we generalized our approach for $n$ villages, $m$ steps, and a maximum truck capacity of $C$, it is interesting to see what happens for other values of $n$ (We have already shown in the above exercises that our truck capacity and our number of steps are easy to adapt). For $n > 10$ we can still represent clearly with our use of variables what village we want to indicate. So if we keep the notation then it is still clear that \texttt{v1111\_5} represents village 1111 at step 5.

	\section*{Problem 2: Filling bottles}
	\begin{longtable}[c]{@{}lllllll@{}}
		\toprule
		A & B & C & bottle\_option & action\_option & pour\_in &
		poured\tabularnewline
		\midrule
		\endhead
		3 & 0 & 0 & B & fill & (A) & (0)\tabularnewline
		3 & 72 & 0 & B & pour & A & 72\tabularnewline
		75 & 0 & 0 & A & pour & C & 16\tabularnewline
		59 & 0 & 16 & C & pour & B & 16\tabularnewline
		59 & 16 & 0 & A & pour & C & 16\tabularnewline
		43 & 16 & 16 & C & pour & B & 16\tabularnewline
		43 & 32 & 0 & A & pour & C & 16\tabularnewline
		27 & 32 & 16 & C & pour & B & 16\tabularnewline
		27 & 48 & 0 & A & pour & C & 16\tabularnewline
		11 & 48 & 16 & C & pour & B & 16\tabularnewline
		11 & 64 & 0 & C & fill & (A) & (1)\tabularnewline
		11 & 64 & 16 & C & pour & B & 8\tabularnewline
		11 & 72 & 8 & B & empty & (A) & (0)\tabularnewline
		11 & 0 & 8 & A & pour & B & 11\tabularnewline
		0 & 11 & 8 & C & pour & A & 8\tabularnewline
		8 & 11 & 0 & A & fill & (A) & (0)\tabularnewline
		144 & 11 & 0 & C & fill & (A) & (0)\tabularnewline
		144 & 11 & 16 & A & empty & (A) & (0)\tabularnewline
		0 & 11 & 16 & C & pour & A & 16\tabularnewline
		16 & 11 & 0 & C & fill & (A) & (0)\tabularnewline
		16 & 11 & 16 & C & pour & A & 16\tabularnewline
		32 & 11 & 0 & C & fill & (A) & (0)\tabularnewline
		32 & 11 & 16 & C & pour & A & 16\tabularnewline
		48 & 11 & 0 & C & fill & (A) & (0)\tabularnewline
		48 & 11 & 16 & C & pour & B & 16\tabularnewline
		48 & 27 & 0 & A & pour & B & 45\tabularnewline
		3 & 72 & 0 & B & empty & (A) & (0)\tabularnewline
		3 & 0 & 0 & B & fill & (A) & (0)\tabularnewline
		\bottomrule
		\caption{assignment 2a}
		\label{tab:2a}
	\end{longtable}
	
	\begin{longtable}[c]{@{}lllllll@{}}
		\toprule
		A & B & C & bottle\_option & action\_option & pour\_in &
		poured\tabularnewline
		\midrule
		\endhead
		3 & 0 & 0 & B & fill & (A) & (0)\tabularnewline
		3 & 72 & 0 & B & pour & C & 28\tabularnewline
		3 & 44 & 28 & C & pour & A & 28\tabularnewline
		31 & 44 & 0 & B & pour & C & 28\tabularnewline
		31 & 16 & 28 & C & pour & A & 28\tabularnewline
		59 & 16 & 0 & C & fill & (A) & (1)\tabularnewline
		59 & 16 & 28 & C & pour & A & 28\tabularnewline
		87 & 16 & 0 & B & pour & C & 16\tabularnewline
		87 & 0 & 16 & A & pour & B & 72\tabularnewline
		15 & 72 & 16 & B & pour & C & 12\tabularnewline
		15 & 60 & 28 & C & pour & A & 28\tabularnewline
		43 & 60 & 0 & B & pour & C & 28\tabularnewline
		43 & 32 & 28 & C & pour & A & 28\tabularnewline
		71 & 32 & 0 & B & pour & C & 28\tabularnewline
		71 & 4 & 28 & C & pour & A & 28\tabularnewline
		99 & 4 & 0 & B & pour & C & 4\tabularnewline
		99 & 0 & 4 & B & fill & (A) & (0)\tabularnewline
		99 & 72 & 4 & B & pour & A & 45\tabularnewline
		144 & 27 & 4 & A & pour & C & 24\tabularnewline
		120 & 27 & 28 & C & pour & B & 28\tabularnewline
		120 & 55 & 0 & A & pour & C & 28\tabularnewline
		92 & 55 & 28 & C & pour & B & 17\tabularnewline
		92 & 72 & 11 & B & empty & (A) & (1)\tabularnewline
		92 & 0 & 11 & C & pour & B & 11\tabularnewline
		92 & 11 & 0 & A & pour & C & 28\tabularnewline
		64 & 11 & 28 & C & empty & (A) & (1)\tabularnewline
		64 & 11 & 0 & A & pour & C & 28\tabularnewline
		36 & 11 & 28 & C & empty & (A) & (1)\tabularnewline
		36 & 11 & 0 & A & pour & C & 28\tabularnewline
		8 & 11 & 28 & A & fill & (A) & (0)\tabularnewline
		144 & 11 & 28 & C & empty & (A) & (0)\tabularnewline
		144 & 11 & 0 & A & pour & C & 28\tabularnewline
		116 & 11 & 28 & B & pour & A & 11\tabularnewline
		127 & 0 & 28 & C & pour & B & 28\tabularnewline
		127 & 28 & 0 & A & pour & C & 28\tabularnewline
		99 & 28 & 28 & C & empty & (A) & (1)\tabularnewline
		99 & 28 & 0 & A & pour & C & 28\tabularnewline
		71 & 28 & 28 & C & empty & (A) & (1)\tabularnewline
		71 & 28 & 0 & A & pour & C & 28\tabularnewline
		43 & 28 & 28 & C & empty & (A) & (1)\tabularnewline
		43 & 28 & 0 & A & pour & C & 28\tabularnewline
		15 & 28 & 28 & C & empty & (A) & (1)\tabularnewline
		15 & 28 & 0 & B & fill & (A) & (0)\tabularnewline
		15 & 72 & 0 & B & pour & C & 28\tabularnewline
		15 & 44 & 28 & C & empty & (A) & (0)\tabularnewline
		15 & 44 & 0 & B & pour & C & 28\tabularnewline
		15 & 16 & 28 & B & pour & A & 16\tabularnewline
		31 & 0 & 28 & C & empty & (A) & (1)\tabularnewline
		31 & 0 & 0 & A & pour & C & 28\tabularnewline
		3 & 0 & 28 & C & empty & (A) & (0)\tabularnewline
		3 & 0 & 0 & B & fill & (A) & (0)\tabularnewline
		\bottomrule
		\caption{assignment 2c}
		\label{tab:2c}
	\end{longtable}

	\subsection*{Solution:}
	
	
	\section*{Problem 3: Filling bottles}
	For this problem we use {\tt Prover9} to automatically prove the properties, or {\tt Mace4} to generate a counter example in case {\tt Prover9} does not manage to give a proof.
	
	\subsection*{Problem 3a}
	The following definitions are given:
	$$ x \** (y \** z) = (x \** y) \** z$$
	$$x \** I = x$$
	$$x \** inv(x) = I$$
	
	And we need to prove, or give a counter example for the following definitions:
	$$I \** x = x$$
	$$inv(inv(x)) = x$$
	$$inv(x) \** x = I$$ 
	$$x \** y = y \** x$$
	
	First, we define two operations, {\tt @} as the binary operator, and {\tt inv} as the inverse operation:
	
	{\tt op(450, infix, @). }
	
	{\tt op(410, prefix\_paren, inv).}\\
	
	Then we tell {\tt Prover9} our properties: 
	
	{\tt x @ (y @ z) = (x @ y) @ z.}
	
	{\tt x @ I = x.}
	 
	{\tt x @ inv(x) = I.}
	\\
	\\
	\textbf{PROOF 1. \tt{ I @ x = x.}}\\     
	{\tt 1 I @ x = x \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv(x) = I.  [assumption].}\\
	{\tt 6 I @ c1 != c1.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv(x) @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv(inv(x)) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv(inv(y)) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 17 \$F.  [resolve(16,a,6,a)].}\\
	\\
	\textbf{PROOF 2. {\tt  inv(inv(x)) = x.}}\\        
	{\tt 1 inv (inv x) = x \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv x = I.  [assumption].}\\
	{\tt 6 inv (inv c1) != c1.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv x @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv (inv x) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv (inv y) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 19 x @ (inv x @ y) = y.  [back\_rewrite(8),rewrite([16(5)])].}\\
	{\tt 22 inv (inv x) = x.  [para(5(a,1),19(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 23 \$F.  [resolve(22,a,6,a)].}\\
	\\
	\textbf{PROOF 3. {\tt  inv(x) @ x = I.}}\\      
	{\tt 1 inv x @ x = I \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv x = I.  [assumption].}\\
	{\tt 6 inv c1 @ c1 != I.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv x @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv (inv x) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv (inv y) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 19 x @ (inv x @ y) = y.  [back\_rewrite(8),rewrite([16(5)])].}\\
	{\tt 22 inv (inv x) = x.  [para(5(a,1),19(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 24 inv x @ x = I.  [para(22(a,1),5(a,1,2))].}\\
	{\tt 25 \$F.  [resolve(24,a,6,a)].}\\
	\\
	\textbf{COUNTEREXAMPLE 4. {\tt  x @ y = y @ x}}\\
	%{\tt interpretation( 6, [number = 1,seconds = 0], [}\\
	%{\tt \indent function(@(\_,\_), [}\\
	%{\tt \indent \indent 0,1,2,3,4,5,}\\
	%{\tt \indent \indent 1,0,3,2,5,4,}\\
	%{\tt \indent \indent 2,4,0,5,1,3,}\\
	%{\tt \indent \indent 3,5,1,4,0,2,}\\
	%{\tt \indent \indent 4,2,5,0,3,1,}\\
	%{\tt \indent \indent 5,3,4,1,2,0]),}\\
	%{\tt \indent function(I, [0]),}\\
	%{\tt \indent function(c1, [1]),}\\
	%{\tt \indent function(c2, [2]),}\\
	%{\tt \indent function(inv(\_), [0,1,2,4,3,5])]).}\\
	%\\
	{\tt I : 0}\\
	{\tt }\\
	{\tt c1 : 1}\\
	{\tt }\\
	{\tt c2 : 2}\\
	{\tt }\\
	{\tt inv :}\\
	{\tt \indent 0 1 2 3 4 5}\\
	{\tt ---------------}\\
	{\tt \indent 0 1 2 4 3 5}\\
	{\tt }\\
	\\
	\\
	{\tt @ :}\\
	{\tt \indent $/$ | 0 1 2 3 4 5}\\
	{\tt \indent --+------------}\\
	{\tt \indent 0 | 0 1 2 3 4 5}\\
	{\tt \indent 1 | 1 0 3 2 5 4}\\
	{\tt \indent 2 | 2 4 0 5 1 3}\\
	{\tt \indent 3 | 3 5 1 4 0 2}\\
	{\tt \indent 4 | 4 2 5 0 3 1}\\
	{\tt \indent 5 | 5 3 4 1 2 0}\\
	\\
	Since {\tt Mace4} increments the set by 1 each time, the smallest set for which\\ $x \** y = y \** x$ does not hold, is 6.
	
	\subsection*{Problem 3b}
	
	

\end{document}
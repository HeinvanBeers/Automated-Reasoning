\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{color, colortbl}
\definecolor{Highlight}{rgb}{0.3, 0.76, 0.97}
\author{Hein van Beers \qquad Student number: 0765658 \\{\tt h.a.v.beers@student.tue.nl}\\ \\ Jeroen van Hoof \qquad Student number: 0778486 \\{\tt j.m.a.p.v.hoof@student.tue.nl}}
\title{Automated Reasoning\\
	 \large Practical assignment, Part II}
\begin{document}
	\maketitle
	
	\section*{Problem 1: Non-self-supporting Villages}
	Three non-self-supporting villages A, B and C in the middle of nowhere consume one food package each per time unit. The required food packages are delivered by a truck, having a capacity of 300 food packages. The locations of the villages are given, together with the number of time units it takes the truck to travel from one village to another, including loading or delivering. The truck has to pick up its food packages at location S containing an unbounded supply. The villages only have a limited capacity to store food packages: for A and B this capacity is 120, for C it is 200.
	
	\subsection*{Solution:}
	We generalize this problem to $n$ villages and a truck capacity of $C$. We also have a variable $m$ which represents the amount of steps we perform in the model. Each step corresponds to a change in the position of the truck. For each village we then introduce $n * (m+2)$ integer variables $v_{i\_j}$ for $i=1,...,n$ and $j=0,...,m+1$, where $i$ indicates the number of each village and $j$ is the number of steps that have been performed. So now we have a variable $v_{i\_j}$ that represents the amount of food packages in village $i$ after $j$ steps have been performed. Next, we also introduce $m+2$ integer variables $p_j$, $t_j$ and $d_j$ for $j=0,...,m+1$, where $p_j$ represents the position of the truck after $j$ number of steps have been performed, $t_j$ represents the load of the truck after $j$ number of steps have been performed, and $d_j$ represents the amount of food packages that are being delivered at step $j$.\\
	
	Since for each village $i$ the food capacity $v_{i\_j}$ may not exceed its maximum capacity $max_i$, neither may get below zero for any step $j$, we introduce the following formula
\[ \bigwedge_{j=0}^{m+1} \bigwedge_{i=1}^n (v_{i\_j} >= 0) \wedge (v_{i\_j} <= max_i).\]
Where $max_i$ is the maximum capacity of village $i$. In the table below you can see the maximum capacities of villages A, B and C, together with their corresponding integer values.

\begin{table}[H]
\centering
\caption{Maximum capacities of each village}
\label{my-label}
\begin{tabular}{c|c|c}
\textbf{Village} & \textbf{Corresponding $i$} & \textbf{Maximum capacity} \\ \hline
A	&	1	&	120\\ \hline
B	&	2	&	120\\ \hline
C	&	3	&	200
\end{tabular}
\end{table}

	The position $p_j$ of the truck at each step $j$ should be bounded below by zero and above by the number of villages we have in total. Also the capacity of the truck $t_j$ at each step $j$ should be bounded below by zero and above by the maximum capacity of the truck $C$. Finally, we also need a bound on the capacity that is being delivered $d_j$ at each step $j$, since we can never deliver a negative value. The bounds for these three variables can be represented with the following formula
	\[ \bigwedge_{j=0}^{m+1} (p_j >= 0) \wedge (p_j <= n) \wedge (t_j >= 0) \wedge (t_j <= C) \wedge (d_j >= 0).\]
	Where $m$ is the amount of steps we take, $n$ is the total number of villages (in our case 3), and $C$ is the maximum capacity of the truck.\\

Finally, we need to implement the steps that can be taken at each step of the model. The steps that can be taken depend on the current position of the truck, since in the next step, the truck can only go to neighbouring villages. So let $X_i$ be the set of neighbouring villages of village $i$ and let $f_i(x)$ be a function that determines the costs of going from village $i$ to village $x$. We now can easily express the steps and their corresponding changes in the variables. Since each step contains several variables that need to be updated, we will first give the different parts of the entire formula and explain them. Finally, we will give the entire formula.\\

As said before, the variables of the (immediate) next step depend on the current position of the truck. This is why we have a case distinction on each position in time $p_j$ of the truck. The formula below represents the possibilities for step $j$ and current position $0$
\[ (p_j = i) \Rightarrow \cdots \]
Where $i \in {0,...,n}$ represents the position of the truck at step $j$.\\

Next, we need to define what happens when we know the position of the truck at step $j$, this is what comes after the implication mentioned above. The first thing we observe is the amount of food packages that the truck delivers at step $j$. When the truck is at the supply stack (position 0), we do not deliver anything. This can be represented by the following formula

\[ \cdots ( (d_j = 0) \wedge \cdots \]

But when the truck is at a village, we can deliver any amount of food packages, as long as the current capacity of the village plus the amount we deliver does not exceed the total capacity of that village. So the amount that we deliver to the village should be less than or equal to the maximum capacity of the village minus the current capacity of that village. This can be represented by the following formula

\[ \cdots ( (d_j \leq max(i) - v_{i\_j}) \wedge \cdots \]

After this, we need to define what our next steps can be and what the consequences of taking a specific step are. This can be done by looking at the neighbouring villages of the current position of the truck. If we are at position $i$, then the neighbouring villages of position $i$ are given by the set $X_i$. For the case that the truck is currently at the supply stack (position 0), we again have a special case. Since now the capacity of each village only needs to be reduced in the next step. This needs to be done for each neighbouring village of the current position. This is represented by the following formula

\[ \cdots (\bigvee_{x \in X_0} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (v_{y\_j+1} = v_{y\_j} - f_0(x))) \wedge \cdots \]
Where $x$ indicates the village we can choose next, $y$ indicates all villages, since their supply needs to be reduced, and $f_0(x)$ indicates the amount of time it costs from going from position 0 to village $x$.

When the truck is currently at a village, we can also deliver to that village. So in that case, the supply of that specific village not only gets reduced, but also gets increased again by the amount of food packages we deliver. This can be represented by the following formula

\[ \cdots (\bigvee_{x \in X_i} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \cdots \]
Where $x$ indicates the village we can choose next, $y$ indicates all villages, since their supply needs to be reduced, and $f_i(x)$ indicates the amount of time it costs from going from position $i$ to position $x$. We see a distinction between the case that the village from which we are updating the supply is the same as the village we are currently in ($y=i$) and all the other cases ($y \neq i$). When $y=i$ we also add the amount of food packages that we deliver in that step $d_j$ to the supply of that village. The other cases only get their supply being reduced as in the case described above for position 0.

Finally, we also need to set the load of the truck, since this also changes each step. The value of the truck also depends on the village we choose for the next step, since when we are at the supply stack in the next step, we do not deliver anything, but we can increase the load of our truck in that position. In all the other positions, we only can reduce the load of the truck. So we again have a case distinction. When the next position we choose is equal to position 0 ($p_{j+1} = 0$), we get the following formula

\[ \cdots ((p_j{j+1} = 0) \wedge (t_{j+1} \geq t_j))))).\]

When the next position is not the supply stack ($p_{j+1} \neq 0$), we need to reduce the load of the truck by the amount we deliver in that step. This can be represented by the following formula

\[ \cdots ((p_{j+1} \neq 0) \wedge (t_{j+1} = t_j - d_{j+1}))))).\]

So the entire formula for the case that the truck is currently at the supply stack is given below
\[ (p_j = 0) \Rightarrow ( (d_j = 0) \wedge \]
\[ (\bigvee_{x \in X_0} ((p_{j+1} = x) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (v_{y\_j+1} = v_{y\_j} - f_0(x))) \wedge \]
\[ (t_{j+1} = t_j - d_{j+1})))).\]

Similarly, we can also do this for all other positions $i$, but then we only need to add that the delivery changes and that the capacity of the villages also changes if the truck delivers to its village. We can see the possibilities for step $j$ and current position $i \neq 0$ in the formula below

\[ (p_j = i) \Rightarrow ( (d_j \leq max(i) - v_{i\_j}) \wedge \]
\[ (\bigvee_{x \in X_i} ((p_{j+1} = 0) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(y) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \]
\[ (t_{j+1} \geq t_j)) \vee ((p_{j+1} \neq 0) \wedge \]
\[ (\bigwedge_{1 \leq y \leq n} (((y=i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(y) + d_j)) \vee \]
\[ ((y \neq i) \wedge (v_{y\_j+1} = v_{y\_j} - f_i(x))))) \wedge \]
\[ (t_{j+1} = t_j - d_{j+1})))).\]

This formula is quite big and looks impressive, but can easily be expressed in SMT syntax, for instance, for $n=3$, $m=20$ and the connections between the villages are as described in the assignment, one can generate the following SMT code\\

{\footnotesize

{\tt (benchmark Assignment1.smt}

{\tt :logic QF\_UFLIA}

{\tt :extrafuns (}

{\tt (v1\_0 Int) (v2\_0 Int) (v3\_0 Int) }

{\tt (v1\_1 Int) (v2\_1 Int) (v3\_1 Int) }

{\tt (v1\_2 Int) (v2\_2 Int) (v3\_2 Int) }

$\cdots \cdots$

{\tt (p\_0 Int) (t\_0 Int) (d\_0 Int) }

{\tt (p\_1 Int) (t\_1 Int) (d\_1 Int) }

{\tt (p\_2 Int) (t\_2 Int) (d\_2 Int) }

$\cdots \cdots$

{\tt )}

{\tt :formula}

{\tt   (and}

{\tt ;Initialization of variables }

{\tt (= p\_0 0) (= v1\_0 40) (= v2\_0 30) (= v3\_0 145) (= t\_0 300) }

{\tt ;Setting the bounds of the variables }

{\tt (>= v1\_0 0) (<= v1\_0 120) (>= v2\_0 0) (<= v2\_0 120) (>= v3\_0 0) (<= v3\_0 200) }

{\tt (>= v1\_1 0) (<= v1\_1 120) (>= v2\_1 0) (<= v2\_1 120) (>= v3\_1 0) (<= v3\_1 200) }

{\tt (>= v1\_2 0) (<= v1\_2 120) (>= v2\_2 0) (<= v2\_2 120) (>= v3\_2 0) (<= v3\_2 200) }

$\cdots \cdots$

{\tt (>= p\_0 0) (<= p\_0 3) (>= t\_0 0) (<= t\_0 300) (>= d\_0 0) }

{\tt (>= p\_1 0) (<= p\_1 3) (>= t\_1 0) (<= t\_1 300) (>= d\_1 0) }

{\tt (>= p\_2 0) (<= p\_2 3) (>= t\_2 0) (<= t\_2 300) (>= d\_2 0) }

$\cdots \cdots$

{\tt ;Taking the first step in the model }\\

{\tt ;If the current position is equal to the supply stack }

{\tt (implies (= p\_0 0) (and (= d\_0 0) }

{\tt          (or (and (= p\_1 1) (= v1\_1 (- v1\_0 29)) (= v2\_1 (- v2\_0 29)) (= v3\_1 (- v3\_0 29)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 2) (= v1\_1 (- v1\_0 21)) (= v2\_1 (- v2\_0 21)) (= v3\_1 (- v3\_0 21)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village A }

{\tt (implies (= p\_0 1) (and (<= d\_0 (- 120 v1\_0)) }

{\tt          (or (and (= p\_1 0) (= v1\_1 (- (+ v1\_0 d\_0) 29)) (= v2\_1 (- v2\_0 29)) (= v3\_1 (- v3\_0 29)) (>= t\_1 t\_0)) }

{\tt              (and (= p\_1 2) (= v1\_1 (- (+ v1\_0 d\_0) 17)) (= v2\_1 (- v2\_0 17)) (= v3\_1 (- v3\_0 17)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 3) (= v1\_1 (- (+ v1\_0 d\_0) 32)) (= v2\_1 (- v2\_0 32)) (= v3\_1 (- v3\_0 32)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village B }

{\tt (implies (= p\_0 2) (and (<= d\_0 (- 120 v2\_0)) }

{\tt          (or (and (= p\_1 0) (= v1\_1 (- v1\_0 21)) (= v2\_1 (- (+ v2\_0 d\_0) 21)) (= v3\_1 (- v3\_0 21)) (>= t\_1 t\_0)) }

{\tt              (and (= p\_1 1) (= v1\_1 (- v1\_0 17)) (= v2\_1 (- (+ v2\_0 d\_0) 17)) (= v3\_1 (- v3\_0 17)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 3) (= v1\_1 (- v1\_0 37)) (= v2\_1 (- (+ v2\_0 d\_0) 37)) (= v3\_1 (- v3\_0 37)) (= t\_1 (- t\_0 d\_1)))))) }\\

{\tt ;If the current position is equal to village C }

{\tt (implies (= p\_0 3) (and (<= d\_0 (- 200 v3\_0)) }

{\tt          (or (and (= p\_1 1) (= v1\_1 (- v1\_0 32)) (= v2\_1 (- v2\_0 32)) (= v3\_1 (- (+ v3\_0 d\_0) 32)) (= t\_1 (- t\_0 d\_1))) }

{\tt              (and (= p\_1 2) (= v1\_1 (- v1\_0 37)) (= v2\_1 (- v2\_0 37)) (= v3\_1 (- (+ v3\_0 d\_0) 37)) (= t\_1 (- t\_0 d\_1)))))) }

$\cdots \cdots$

{\tt )) }
}

	\subsection*{Problem 1a}
	We need to show that it is impossible to deliver food packages in such a way that each of the villages consumes one food package per time unit forever. In order to show that this is impossible, we need to find a value for the amount of steps $m$, for which one or more villages have a shortage of food packages. We just tried several cases for $m$ and discovered that with $m=20$ we can still deliver food packages, without any village coming into trouble. But with $m=21$ we see that \texttt{yices} returns \texttt{unsat}, which means that it is not possible to deliver packages for more than 20 steps and therefore also not forever. Table \ref{tab:1a} shows the steps for $m=20$ and which does not yet result in a shortage of food, while any step after step 20 will result in a food shortage.
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			step & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 300 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 189 & 111 & 19 & 9 & 124\tabularnewline
			2 & 1 & 71 & 118 & 2 & 103 & 107\tabularnewline
			3 & 0 & 300 & 0 & 91 & 74 & 78\tabularnewline
			4 & 2 & 234 & 66 & 70 & 53 & 57\tabularnewline
			5 & 3 & 66 & 168 & 33 & 82 & 20\tabularnewline
			6 & 1 & 0 & 66 & 1 & 50 & 156\tabularnewline
			7 & 0 & 300 & 0 & 38 & 21 & 127\tabularnewline
			8 & 2 & 180 & 120 & 17 & 0 & 106\tabularnewline
			9 & 1 & 60 & 120 & 0 & 103 & 89\tabularnewline
			10 & 0 & 300 & 0 & 91 & 74 & 60\tabularnewline
			11 & 2 & 233 & 67 & 70 & 53 & 39\tabularnewline
			12 & 3 & 70 & 163 & 33 & 83 & 2\tabularnewline
			13 & 1 & 4 & 66 & 1 & 51 & 133\tabularnewline
			14 & 0 & 296 & 0 & 38 & 22 & 104\tabularnewline
			15 & 2 & 179 & 117 & 17 & 1 & 83\tabularnewline
			16 & 1 & 64 & 115 & 0 & 101 & 66\tabularnewline
			17 & 3 & 15 & 49 & 83 & 69 & 34\tabularnewline
			18 & 1 & 15 & 0 & 51 & 37 & 51\tabularnewline
			19 & 2 & 1 & 14 & 34 & 20 & 34\tabularnewline
			20 & 1 & 1 & 0 & 17 & 17 & 17\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{20 steps, 300 truck capacity}
		\label{tab:1a}
	\end{table}
		
	\subsection*{Problem 1b}
	%Als er een loop is en we vinden binnen aantal stappen een en in die loop is het mogelijk om te blijven deliveren en je komt in precies dezelfde states weer terug, dan kunnen we oneindig doorgaan.
	For this question we need to show that with a truck capacity of 320 food packages, it is possible to deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	To solve problems \textbf{b} and \textbf{c}, we need to find a loop that includes a finite amount of legal states. Once we find such a loop, we can repeat it infinitely, and conclude that it is possible to deliver food packages in such a way that each of the villages consumes one food package per time unit forever.\\
	
	A loop is defined as a set of succeeding states with a first state $S_i$ and last state $S_j$, where $S_i$ and $S_j$ are similar and $j > i$.
	
	Take two states $i$ and $j$, and take $n$ as the number of villages. Then two states are similar if and only if:
	$$similar(i, j) \Leftrightarrow p_i = p_j \wedge t_i = t_j \wedge \forall (k: 1 \leq k \leq n : v_{k\_i} = v_{k\_j})$$
	
	So, if we take $m$ as the number of steps, a solution that holds a loop, can be defined with:
	%$$\exists (i, j: 0 \leq i,j \leq m \wedge j > i: similar(i, j))$$
	
	$$\bigvee_{i, j}^m j > i \wedge similar(i, j)$$
	
	We define a loop in smt as follows. For all $0 \leq i, j \leq m$ with $j > i$ we have {\tt (= p\_$i$ p\_$j$) (= t\_$i$ t\_$j$)}, and for each village $n$, we have: {\tt (= v$n$\_$i$ v$n$\_$j$)}. We then include this code together with the original code from the previous part of this assignment and when we run the program with $m=25$ and a truck capacity of 320, we get the result that is shown in Table \ref{tab:1b}.\\
	
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			s & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 320 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 281 & 39 & 19 & 9 & 124\tabularnewline
			2 & 1 & 163 & 118 & 2 & 31 & 107\tabularnewline
			3 & 2 & 57 & 106 & 103 & 14 & 90\tabularnewline
			4 & 0 & 319 & 0 & 82 & 99 & 69\tabularnewline
			5 & 1 & 253 & 66 & 53 & 70 & 40\tabularnewline
			6 & 3 & 66 & 187 & 87 & 38 & 8\tabularnewline
			7 & 2 & 0 & 66 & 50 & 1 & 158\tabularnewline
			\rowcolor{Highlight}
			8 & 0 & 271 & 0 & 29 & 46 & 137\tabularnewline
			9 & 1 & 151 & 120 & 0 & 17 & 108\tabularnewline
			10 & 2 & 32 & 119 & 103 & 0 & 91\tabularnewline
			11 & 0 & 319 & 0 & 82 & 98 & 70\tabularnewline
			12 & 1 & 253 & 66 & 53 & 69 & 41\tabularnewline
			13 & 3 & 67 & 186 & 87 & 37 & 9\tabularnewline
			14 & 2 & 0 & 67 & 50 & 0 & 158\tabularnewline
			\rowcolor{Highlight}
			15 & 0 & 271 & 0 & 29 & 46 & 137\tabularnewline
			16 & 1 & 151 & 120 & 0 & 17 & 108\tabularnewline
			17 & 2 & 32 & 119 & 103 & 0 & 91\tabularnewline
			18 & 0 & 320 & 0 & 82 & 98 & 70\tabularnewline
			19 & 1 & 280 & 40 & 53 & 69 & 41\tabularnewline
			20 & 3 & 155 & 125 & 61 & 37 & 9\tabularnewline
			21 & 2 & 110 & 45 & 24 & 0 & 97\tabularnewline
			22 & 1 & 36 & 74 & 7 & 28 & 80\tabularnewline
			23 & 2 & 0 & 36 & 64 & 11 & 63\tabularnewline
			24 & 0 & 16 & 0 & 43 & 26 & 42\tabularnewline
			25 & 2 & 0 & 16 & 22 & 5 & 21\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{25 steps, 320 truck capacity}
		\label{tab:1b}
	\end{table}
	
	This table shows that step 8 and step 15 are exactly the same and therefore we have a loop from step 8 to step 15. We also see that we can reach state 15 from the initial state without any village going below zero food packages. This means that we can reach state 15 and then continue with state 9 again, then 10, etc. without ever having any village with a shortage of food packages. So from this we can conclude that it is possible to deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	\subsection*{Problem 1c}
	Finally, we also need to check the same as for question 1b, but now with a truck capacity of 318 food packages. Table \ref{tab:1c} shows that step 5 and step 25 are exactly the same (what we deliver in the step does not have to be the same) and we can reach step 25 without having any village with a shortage of food packages. So this implies that with a truck capacity of 318 food packages, we can also deliver food packages in such a way that the villages consume each one food package per time unit forever.
	
	\begin{table}[!htb]
		\begin{longtable}[c]{@{}|l|l|l|l|l|l|l|@{}}
			\toprule
			s & p & t & d & v1 & v2 & v3\tabularnewline
			\midrule
			\endhead
			0 & 0 & 318 & 0 & 40 & 30 & 145\tabularnewline
			1 & 2 & 207 & 111 & 19 & 9 & 124\tabularnewline
			2 & 1 & 89 & 118 & 2 & 103 & 107\tabularnewline
			3 & 0 & 314 & 0 & 91 & 74 & 78\tabularnewline
			4 & 2 & 247 & 67 & 70 & 53 & 57\tabularnewline
			\rowcolor{Highlight}
			5 & 3 & 68 & 179 & 33 & 83 & 20\tabularnewline
			6 & 1 & 2 & 66 & 1 & 51 & 167\tabularnewline
			7 & 0 & 299 & 0 & 38 & 22 & 138\tabularnewline
			8 & 2 & 241 & 58 & 17 & 1 & 117\tabularnewline
			9 & 1 & 121 & 120 & 0 & 42 & 100\tabularnewline
			10 & 2 & 26 & 95 & 103 & 25 & 83\tabularnewline
			11 & 0 & 318 & 0 & 82 & 99 & 62\tabularnewline
			12 & 1 & 252 & 66 & 53 & 70 & 33\tabularnewline
			13 & 3 & 67 & 185 & 87 & 38 & 1\tabularnewline
			14 & 2 & 0 & 67 & 50 & 1 & 149\tabularnewline
			15 & 0 & 219 & 0 & 29 & 47 & 128\tabularnewline
			16 & 1 & 118 & 101 & 0 & 18 & 99\tabularnewline
			17 & 2 & 0 & 118 & 84 & 1 & 82\tabularnewline
			18 & 0 & 317 & 0 & 63 & 98 & 61\tabularnewline
			19 & 1 & 232 & 85 & 34 & 69 & 32\tabularnewline
			20 & 3 & 71 & 161 & 87 & 37 & 0\tabularnewline
			21 & 2 & 4 & 67 & 50 & 0 & 124\tabularnewline
			22 & 0 & 287 & 0 & 29 & 46 & 103\tabularnewline
			23 & 1 & 200 & 87 & 0 & 17 & 74\tabularnewline
			24 & 2 & 80 & 120 & 70 & 0 & 57\tabularnewline
			\rowcolor{Highlight}
			25 & 3 & 68 & 12 & 33 & 83 & 20\tabularnewline
			\bottomrule
		\end{longtable}
		\caption{25 steps, 318 truck capacity}
		\label{tab:1c}
	\end{table}

{\bf Remark:}
We did not set the load of the truck to be equal to its maximum capacity, each time the truck comes at the supply stack, so the program can choose how much it wants to fill the truck. But if we would do this and set it to the maximum truck capacity, the program would probably be a little bit faster and therefore, more efficient. So this could be added as an improvement to our program.\\

{\bf Generalization:} 
As we generalized our approach for $n$ villages, $m$ steps, and a maximum truck capacity of $C$, it is interesting to see what happens for other values of $n$ (We have already shown in the above exercises that our truck capacity and our number of steps are easy to adapt). For $n > 10$ we can still represent clearly with our use of variables what village we want to indicate. So if we keep the notation then it is still clear that \texttt{v1111\_5} represents village 1111 at step 5.

	\section*{Problem 2: Filling bottles}
	Three bottles can hold 144, 72 and 16 units (say, centiliters), respectively. Initially the
first one contains 3 units of water, the others are empty. The following actions may be performed any number of times:
\begin{itemize}
\item One of the bottles is fully filled, at some water tap.
\item One of the bottles is emptied.
\item The content of one bottle is poured into another one. If it fits, then the full content
is poured, otherwise the pouring stops when the other bottle is full.
\end{itemize}

	\subsection*{Solution:}
	We generalize this problem to $n$ bottles each having a maximum capacity of $max(i)$ for bottle $i$. For each bottle we then introduce one integer variables $b_i$ for $i=1,...,n$, where $i$ indicates the number of each bottle. So now we have a variable $b_i$ that represents the amount of water in bottle $i$. Next, we also introduce an integer variable $bottle\_option$ for indicating on which bottle we execute an action. $bottle\_option$ can take a value in the range [$1..n$], so if $bottle\_option$ has the value $i$, it means that we execute an action on bottle $i$. We then also have an integer variable $action\_option$ for indicating which action we execute. $action\_option$ can take a value in the range [$1..3$], since we only have three actions available. Next, we also introduce an integer variable $pour\_in$ for indication in which bottle we pour the water. Note that this variable is only used when we perform the pour-action (action 3). $pour\_in$ can also take a value in the range [$1..n$], since we can pour the water in any of the $n$ bottles. Finally, we also have an integer variable called $poured$ for keeping track of how much water we pour from one bottle in another during the pour-action. $poured$ can take on a value in the range [$0..max$], where $max$ is the capacity of the biggest bottle that we are using.\\
	
	Since for each bottle $b_i$ we need to define its next state, we have a case distinction on each bottle. In each case we give the next value for the bottle depending on the action taken. When we are looking at the case for bottle $b_i$ and $bottle\_option = i$ and $action\_option = 1$ we fill bottle $b_i$ entirely, for this we introduce the following formula for bottle $b_i$
\[ bottle\_option = i\ \&\ action\_option = 1 : max(i).\]
Where $max(i)$ is the maximum capacity of bottle $b_i$ in units.\\

	When we are looking at the case for bottle $b_i$ and $bottle\_option = i$ and $action\_option = 2$ we empty bottle $b_i$ entirely, for this we introduce the following formula for bottle $b_i$
\[ bottle\_option = i\ \&\ action\_option = 2 : 0.\]

	We now have described the possible values for bottle $b_i$ in the next step for the first two actions. When now $action\_option = 3$ we have several different possibilities. We either empty bottle $b_i$ in one of the other bottles, so in that case $bottle\_option = i$, or we empty one of the other bottles in bottle $b_i$ ($bottle\_option \neq i$).\\
	
	When we are looking at bottle $b_i$ and $bottle\_option = i$ and $action\_option = 3$, we can pour bottle $b_i$ in any of the other bottles. So we have $n-1$ cases, one for each combination with bottle $b_i$. We then still have two possibilities: Either bottle $b_i$ is only partly emptied in bottle $b_j$, since bottle $b_j$ is already full ($b_j + poured = max(j)$), or bottle $b_i$ is entirely emptied in bottle $b_j$. This can easily be described by the following formula
\[ bottle\_option = i\ \&\ action\_option = 3\ \&\ pour\_in = j\ \& \]
\[ ((b_j + poured = max(j)\ \&\ b_i - poured >= 0)\ | \]
\[ (b_j + poured < max(j)\ \&\ b_i - poured = 0)) : b_i - poured;.\]
Where $max(j)$ is the maximum capacity of bottle $b_j$ in units.\\

	Now the remaining case, when we are looking at bottle $b_i$ and $bottle\_option = j$, for any $j \neq i$, and $action\_option = 3$, we pour bottle $b_j$ in bottle $b_i$. So we have $n-1$ cases, one for each combination with bottle $b_i$. We then still have two possibilities: Either bottle $b_j$ is only partly emptied in bottle $b_i$, since bottle $b_i$ is already full ($b_i + poured = max(i)$), or bottle $b_j$ is entirely emptied in bottle $b_i$. This can easily be described by the following formula
\[ bottle\_option = j\ \&\ action\_option = 3\ \&\ pour\_in = i\ \& \]
\[ ((b_i + poured = max(i)\ \&\ b_j - poured >= 0)\ | \]
\[ (b_i + poured < max(i)\ \&\ b_j - poured = 0)) : b_i + poured;.\]
Where $j \neq i$ and $max(i)$ is the maximum capacity of bottle $b_i$ in units.\\

	For any other combination of variables, the capacity of bottle $b_i$ does not changes, so it remains the same. This can be described with the default case
	\[ {\tt TRUE} : b_i \]
	
	The entire formula can easily be expressed in SMV syntax, for instance, for $n=3$ and the capacities of the bottles are as described in the assignment, one can generate the following SMV code\\

{\footnotesize

{\tt MODULE main }

{\tt VAR }

{\tt b1 : 0..144; }

{\tt b2 : 0..72; }

{\tt b3 : 0..16; }

{\tt bottle\_option : 1..3; }

{\tt action\_option : 1..3; }

{\tt pour\_in : 1..3; }

{\tt poured : 0..144; }

\vspace{1em}

{\tt INIT }

{\tt b1 = 3\ \&\ b2 = 0\ \&\ b3 = 0 }

\vspace{1em}

{\tt ASSIGN }

{\tt next(b1) := }

{\tt 	case }


{\tt 		bottle\_option = 1\ \&\ action\_option = 1 : 144; }

{\tt 		bottle\_option = 1\ \&\ action\_option = 2 : 0; }

\vspace{1em}

{\tt 		bottle\_option = 1\ \&\ action\_option = 3\ \&\ pour\_in = 2\ \&\ ((b2 + poured = 72\ \&\ b1 - poured >= 0)\ |\ (b2 + poured < 72\ \&\ b1 - poured = 0)) : b1 - poured; }

{\tt 		bottle\_option = 1\ \&\ action\_option = 3\ \&\ pour\_in = 3\ \&\ ((b3 + poured = 16\ \&\ b1 - poured >= 0)\ |\ (b3 + poured < 16\ \&\ b1 - poured = 0)) : b1 - poured; }

\vspace{1em}

{\tt 		bottle\_option = 2\ \&\ action\_option = 3\ \&\ pour\_in = 1\ \&\ ((b1 + poured = 144\ \&\ b2 - poured >= 0)\ |\ (b1 + poured < 144\ \&\ b2 - poured = 0)) : b1 + poured; }

{\tt 		bottle\_option = 3\ \&\ action\_option = 3\ \&\ pour\_in = 1\ \&\ ((b1 + poured = 144\ \&\ b3 - poured >= 0)\ |\ (b1 + poured < 144\ \&\ b3 - poured = 0)) : b1 + poured; }

{\tt 		TRUE : b1; }

{\tt 	esac; }

\vspace{1em}

{\tt next(b2) := }

{\tt 	case }

$\cdots \cdots$

	
	\subsection*{Problem 2a}
	For the first part of this assignment, we need to determine whether it is possible to arrive at a situation in which the first bottle contains 8 units and the second one contains 11 units. If this is possible, we also need to give a scenario reaching this situation.\\
	
	So if we take $n=3$, since we have three bottles and let $max(1)=144$, $max(2)=72$ and $max(3)=16$ be the corresponding maximum capacities of the three bottles, and we set the initial value of the first bottle to 3 units and of the other two bottles to zero, we can run the program. To check whether it is possible to reach a state in which the first bottle contains 8 units and the second one contains 11 units of water, we also add an LTL specification to the model described above that states the opposite of this requirement. So That it is not possible to reach a state in which the first bottle contains 8 units of water and the second one contains 11 units. This LTL specification is given below.\\

{\tt LTLSPEC G !(b1 = 8 \& b2 = 11) }\\

If we then run the program by executing {\tt nusmv Assignment2-a.smv}, we get the following output.\\

{\tt -- specification  G !(b1 = 8 \& b2 = 11)  is false }

{\tt -- as demonstrated by the following execution sequence }

{\tt Trace Description: LTL Counterexample }

{\tt Trace Type: Counterexample }

{\tt   -- Loop starts here }

{\tt   -> State: 1.1 <- }

{\tt     b1 = 3 }

{\tt     b2 = 0 }

{\tt     b3 = 0 }

{\tt     bottle\_option = 2 }

{\tt     action\_option = 1 }

{\tt     pour\_in = 1 }

{\tt     poured = 0 }

{\tt   -> State: 1.2 <- }

{\tt     b2 = 72 }

{\tt     action\_option = 3 }

{\tt     poured = 72 }

$\cdots \cdots$

From this output, we can see that the specification we checked is false, which means that it is possible to reach a state in which the first bottle contains 8 units and the second bottle contains 11 units of water. If we now look at the counterexample that NuSMV has given to us, we can easily see that it is indeed possible to reach such a state. The counterexample expressed in a table yields the result as displayed in Table \ref{tab:2a}, which is shown below. The highlighted row in the table indicates the step at which the first bottle contains 8 units and the second bottle contains 11 units of water. Note that the values of the variables $pour\_in$ and $poured$ are only used if $action\_option$ is equal to $pour$ (the second action). So for this reason, we have put brackets around the values of those variables, when they are not of importance in that step.

	\begin{longtable}[c]{@{}lllllll@{}}
		\toprule
		B1 & B2 & B3 & bottle\_option & action\_option & pour\_in &
		poured\tabularnewline
		\midrule
		\endhead
		3 & 0 & 0 & B2 & fill & (B1) & (0)\tabularnewline
		3 & 72 & 0 & B2 & pour & B1 & 72\tabularnewline
		75 & 0 & 0 & B1 & pour & B3 & 16\tabularnewline
		59 & 0 & 16 & B3 & pour & B2 & 16\tabularnewline
		59 & 16 & 0 & B1 & pour & B3 & 16\tabularnewline
		43 & 16 & 16 & B3 & pour & B2 & 16\tabularnewline
		43 & 32 & 0 & B1 & pour & B3 & 16\tabularnewline
		27 & 32 & 16 & B3 & pour & B2 & 16\tabularnewline
		27 & 48 & 0 & B1 & pour & B3 & 16\tabularnewline
		11 & 48 & 16 & B3 & pour & B2 & 16\tabularnewline
		11 & 64 & 0 & B3 & fill & (B1) & (1)\tabularnewline
		11 & 64 & 16 & B3 & pour & B2 & 8\tabularnewline
		11 & 72 & 8 & B2 & empty & (B1) & (0)\tabularnewline
		11 & 0 & 8 & B1 & pour & B2 & 11\tabularnewline
		0 & 11 & 8 & B3 & pour & B1 & 8\tabularnewline
		\rowcolor{Highlight}
		8 & 11 & 0 & B1 & fill & (B1) & (0)\tabularnewline
		144 & 11 & 0 & B3 & fill & (B1) & (0)\tabularnewline
		144 & 11 & 16 & B1 & empty & (B1) & (0)\tabularnewline
		0 & 11 & 16 & B3 & pour & B1 & 16\tabularnewline
		16 & 11 & 0 & B3 & fill & (B1) & (0)\tabularnewline
		16 & 11 & 16 & B3 & pour & B1 & 16\tabularnewline
		32 & 11 & 0 & B3 & fill & (B1) & (0)\tabularnewline
		32 & 11 & 16 & B3 & pour & B1 & 16\tabularnewline
		48 & 11 & 0 & B3 & fill & (B1) & (0)\tabularnewline
		48 & 11 & 16 & B3 & pour & B2 & 16\tabularnewline
		48 & 27 & 0 & B1 & pour & B2 & 45\tabularnewline
		3 & 72 & 0 & B2 & empty & (B1) & (0)\tabularnewline
		3 & 0 & 0 & B2 & fill & (B1) & (0)\tabularnewline
		\bottomrule
		\caption{Assignment 2a}
		\label{tab:2a}
	\end{longtable}
	
	\subsection*{Problem 2b}
	For this part of the assignment we again need to check whether it is possible to arrive at a situation in which the first bottle contains 8 units and the second one contains 11 units. If this is possible, we also need to give a scenario reaching this situation. But this time the second bottle is replaced by a bottle that can hold 80 units, and all the rest remains the same. So we again use the same model as for the first part of this assignment. But now the only thing that is different is that the maximum capacity of the second bottle is 80 units, instead of 72.\\
	
	If we then run the program by executing {\tt nusmv Assignment2-b.smv}, we get the following output.\\
	
{\tt -- specification  G !(b1 = 8 \& b2 = 11)  is true}\\

Since the specification is true, it means that it is not possible to reach a state in which the first bottle holds 8 units and the second bottle holds 11 units of water.

	\subsection*{Problem 2c}
	For this last part of the assignment we again need to check whether it is possible to arrive at a situation in which the first bottle contains 8 units and the second one contains 11 units. If this is possible, we also need to give a scenario reaching this situation. But this time the third bottle is replaced by a bottle that can hold 28 units, and all the rest remains the same. So we again use the same model as for the first part of this assignment. But now the only thing that is different is that the maximum capacity of the third bottle is 28 units, instead of 16.\\
	
	If we then run the program by executing {\tt nusmv Assignment2-c.smv}, we get the following output.\\

{\tt -- specification  G !(b1 = 8 \& b2 = 11)  is false }

{\tt -- as demonstrated by the following execution sequence }

{\tt Trace Description: LTL Counterexample }

{\tt Trace Type: Counterexample }

{\tt   -- Loop starts here }

{\tt   -> State: 1.1 <- }

{\tt     b1 = 3 }

{\tt     b2 = 0 }

{\tt     b3 = 0 }

{\tt     bottle\_option = 2 }

{\tt     action\_option = 1 }

{\tt     pour\_in = 1 }

{\tt     poured = 0 }

{\tt   -> State: 1.2 <- }

{\tt     b2 = 72 }

{\tt     action\_option = 3 }

{\tt     pour\_in = 3 }

{\tt     poured = 28 }

$\cdots \cdots$

From this output, we can see that the specification we checked is false, which means that it is possible to reach a state in which the first bottle contains 8 units and the second bottle contains 11 units of water. If we now look at the counterexample that NuSMV has given to us, we can easily see that it is indeed possible to reach such a state. The counterexample expressed in a table yields the result as displayed in Table \ref{tab:2c}, which is shown below. The highlighted row in the table indicates the step at which the first bottle contains 8 units and the second bottle contains 11 units of water. Note that the values of the variables $pour\_in$ and $poured$ are only used if $action\_option$ is equal to $pour$ (the second action). So for this reason, we have put brackets around the values of those variables, when they are not of importance in that step.

	\begin{longtable}[c]{@{}lllllll@{}}
		\toprule
		B1 & B2 & B3 & bottle\_option & action\_option & pour\_in &
		poured\tabularnewline
		\midrule
		\endhead
		3 & 0 & 0 & B2 & fill & (B1) & (0)\tabularnewline
		3 & 72 & 0 & B2 & pour & B3 & 28\tabularnewline
		3 & 44 & 28 & B3 & pour & B1 & 28\tabularnewline
		31 & 44 & 0 & B2 & pour & B3 & 28\tabularnewline
		31 & 16 & 28 & B3 & pour & B1 & 28\tabularnewline
		59 & 16 & 0 & B3 & fill & (B1) & (1)\tabularnewline
		59 & 16 & 28 & B3 & pour & B1 & 28\tabularnewline
		87 & 16 & 0 & B2 & pour & B3 & 16\tabularnewline
		87 & 0 & 16 & B1 & pour & B2 & 72\tabularnewline
		15 & 72 & 16 & B2 & pour & B3 & 12\tabularnewline
		15 & 60 & 28 & B3 & pour & B1 & 28\tabularnewline
		43 & 60 & 0 & B2 & pour & B3 & 28\tabularnewline
		43 & 32 & 28 & B3 & pour & B1 & 28\tabularnewline
		71 & 32 & 0 & B2 & pour & B3 & 28\tabularnewline
		71 & 4 & 28 & B3 & pour & B1 & 28\tabularnewline
		99 & 4 & 0 & B2 & pour & B3 & 4\tabularnewline
		99 & 0 & 4 & B2 & fill & (B1) & (0)\tabularnewline
		99 & 72 & 4 & B2 & pour & B1 & 45\tabularnewline
		144 & 27 & 4 & B1 & pour & B3 & 24\tabularnewline
		120 & 27 & 28 & B3 & pour & B2 & 28\tabularnewline
		120 & 55 & 0 & B1 & pour & B3 & 28\tabularnewline
		92 & 55 & 28 & B3 & pour & B2 & 17\tabularnewline
		92 & 72 & 11 & B2 & empty & (B1) & (1)\tabularnewline
		92 & 0 & 11 & B3 & pour & B2 & 11\tabularnewline
		92 & 11 & 0 & B1 & pour & B3 & 28\tabularnewline
		64 & 11 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		64 & 11 & 0 & B1 & pour & B3 & 28\tabularnewline
		36 & 11 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		36 & 11 & 0 & B1 & pour & B3 & 28\tabularnewline
		\rowcolor{Highlight}
		8 & 11 & 28 & B1 & fill & (B1) & (0)\tabularnewline
		144 & 11 & 28 & B3 & empty & (B1) & (0)\tabularnewline
		144 & 11 & 0 & B1 & pour & B3 & 28\tabularnewline
		116 & 11 & 28 & B2 & pour & B1 & 11\tabularnewline
		127 & 0 & 28 & B3 & pour & B2 & 28\tabularnewline
		127 & 28 & 0 & B1 & pour & B3 & 28\tabularnewline
		99 & 28 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		99 & 28 & 0 & B1 & pour & B3 & 28\tabularnewline
		71 & 28 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		71 & 28 & 0 & B1 & pour & B3 & 28\tabularnewline
		43 & 28 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		43 & 28 & 0 & B1 & pour & B3 & 28\tabularnewline
		15 & 28 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		15 & 28 & 0 & B2 & fill & (B1) & (0)\tabularnewline
		15 & 72 & 0 & B2 & pour & B3 & 28\tabularnewline
		15 & 44 & 28 & B3 & empty & (B1) & (0)\tabularnewline
		15 & 44 & 0 & B2 & pour & B3 & 28\tabularnewline
		15 & 16 & 28 & B2 & pour & B1 & 16\tabularnewline
		31 & 0 & 28 & B3 & empty & (B1) & (1)\tabularnewline
		31 & 0 & 0 & B1 & pour & B3 & 28\tabularnewline
		3 & 0 & 28 & B3 & empty & (B1) & (0)\tabularnewline
		3 & 0 & 0 & B2 & fill & (B1) & (0)\tabularnewline
		\bottomrule
		\caption{Assignment 2c}
		\label{tab:2c}
	\end{longtable}

	{\bf Generalization:} 
As we generalized our approach for $n$ bottles and a maximum bottle capacity of $max(i)$ for each bottle $i$, it is interesting to see what happens for other values of $n$. For $n > 10$ we can still represent clearly with our use of variables what bottle we want to indicate. So if we keep the notation then it is still clear that \texttt{b1111} represents bottle 1111. We have also shown in the exercises that it is easy to change the maximum capacity of a bottle, since it is simply replacing the capacity of the bottle you want to change with a new value.
	
	
	\section*{Problem 3: Exploiting the tools}
	For this problem we use {\tt Prover9} to automatically prove the properties, or {\tt Mace4} to generate a counter example in case {\tt Prover9} does not manage to give a proof.
	
	\subsection*{Problem 3a}
	The following definitions are given:
	$$ x \** (y \** z) = (x \** y) \** z$$
	$$x \** I = x$$
	$$x \** inv(x) = I$$
	
	And we need to prove, or give a counter example for the following definitions:
	$$I \** x = x$$
	$$inv(inv(x)) = x$$
	$$inv(x) \** x = I$$ 
	$$x \** y = y \** x$$
	
	First, we define two operations, {\tt @} as the binary operator, and {\tt inv} as the inverse operation:
	
	{\tt op(450, infix, @). }
	
	{\tt op(410, prefix\_paren, inv).}\\
	
	Then we tell {\tt Prover9} our properties: 
	
	{\tt x @ (y @ z) = (x @ y) @ z.}
	
	{\tt x @ I = x.}
	 
	{\tt x @ inv(x) = I.}
	\\
	\\
	\textbf{PROOF 1. \tt{ I @ x = x.}}\\     
	{\tt 1 I @ x = x \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv(x) = I.  [assumption].}\\
	{\tt 6 I @ c1 != c1.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv(x) @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv(inv(x)) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv(inv(y)) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 17 \$F.  [resolve(16,a,6,a)].}\\
	\\
	\textbf{PROOF 2. {\tt  inv(inv(x)) = x.}}\\        
	{\tt 1 inv (inv x) = x \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv x = I.  [assumption].}\\
	{\tt 6 inv (inv c1) != c1.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv x @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv (inv x) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv (inv y) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 19 x @ (inv x @ y) = y.  [back\_rewrite(8),rewrite([16(5)])].}\\
	{\tt 22 inv (inv x) = x.  [para(5(a,1),19(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 23 \$F.  [resolve(22,a,6,a)].}\\
	\\
	\textbf{PROOF 3. {\tt  inv(x) @ x = I.}}\\      
	{\tt 1 inv x @ x = I \# label(non\_clause) \# label(goal).  [goal].}\\
	{\tt 2 x @ (y @ z) = (x @ y) @ z.  [assumption].}\\
	{\tt 3 (x @ y) @ z = x @ (y @ z).  [copy(2),flip(a)].}\\
	{\tt 4 x @ I = x.  [assumption].}\\
	{\tt 5 x @ inv x = I.  [assumption].}\\
	{\tt 6 inv c1 @ c1 != I.  [deny(1)].}\\
	{\tt 7 x @ (I @ y) = x @ y.  [para(4(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 8 x @ (inv x @ y) = I @ y.  [para(5(a,1),3(a,1,1)),flip(a)].}\\
	{\tt 13 I @ inv (inv x) = x.  [para(5(a,1),8(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 15 x @ inv (inv y) = x @ y.  [para(13(a,1),3(a,2,2)),rewrite([4(2)])].}\\
	{\tt 16 I @ x = x.  [para(13(a,1),7(a,2)),rewrite([15(5),7(4)])].}\\
	{\tt 19 x @ (inv x @ y) = y.  [back\_rewrite(8),rewrite([16(5)])].}\\
	{\tt 22 inv (inv x) = x.  [para(5(a,1),19(a,1,2)),rewrite([4(2)]),flip(a)].}\\
	{\tt 24 inv x @ x = I.  [para(22(a,1),5(a,1,2))].}\\
	{\tt 25 \$F.  [resolve(24,a,6,a)].}\\
	\\
	\textbf{COUNTEREXAMPLE 4. {\tt  x @ y = y @ x}}\\
	%{\tt interpretation( 6, [number = 1,seconds = 0], [}\\
	%{\tt \indent function(@(\_,\_), [}\\
	%{\tt \indent \indent 0,1,2,3,4,5,}\\
	%{\tt \indent \indent 1,0,3,2,5,4,}\\
	%{\tt \indent \indent 2,4,0,5,1,3,}\\
	%{\tt \indent \indent 3,5,1,4,0,2,}\\
	%{\tt \indent \indent 4,2,5,0,3,1,}\\
	%{\tt \indent \indent 5,3,4,1,2,0]),}\\
	%{\tt \indent function(I, [0]),}\\
	%{\tt \indent function(c1, [1]),}\\
	%{\tt \indent function(c2, [2]),}\\
	%{\tt \indent function(inv(\_), [0,1,2,4,3,5])]).}\\
	%\\
	{\tt I : 0}\\
	{\tt }\\
	{\tt c1 : 1}\\
	{\tt }\\
	{\tt c2 : 2}\\
	{\tt }\\
	{\tt inv :}\\
	{\tt \indent 0 1 2 3 4 5}\\
	{\tt ---------------}\\
	{\tt \indent 0 1 2 4 3 5}\\
	{\tt }\\
	\\
	\\
	{\tt @ :}\\
	{\tt \indent $/$ | 0 1 2 3 4 5}\\
	{\tt \indent --+------------}\\
	{\tt \indent 0 | 0 1 2 3 4 5}\\
	{\tt \indent 1 | 1 0 3 2 5 4}\\
	{\tt \indent 2 | 2 4 0 5 1 3}\\
	{\tt \indent 3 | 3 5 1 4 0 2}\\
	{\tt \indent 4 | 4 2 5 0 3 1}\\
	{\tt \indent 5 | 5 3 4 1 2 0}\\
	\\
	Since {\tt Mace4} increments the set by 1 each time, the smallest set for which\\ $x \** y = y \** x$ does not hold, is 6.
	
	\subsection*{Problem 3b}
	To solve this problem, we must first define the rules of rewriting. Take $\rightarrow_R$ as the rewrite relation and let $\rightarrow_{RR}$ indicate zero or more rewrite steps.\\
	\\
	Then the rules that define rewriting are:
	\begin{itemize}
		\item $x \rightarrow_{RR} x$
		\item $x \rightarrow_R y \Rightarrow a(x, z) \rightarrow_R a(y, z)$
		\item $x \rightarrow_R y \Rightarrow a(z, x) \rightarrow_R a(z, y)$
		\item $x \rightarrow_{RR} y \wedge y \rightarrow_{R} z \Rightarrow x \rightarrow_{RR} z$
	\end{itemize}
	We add the given rule to this:
	\begin{itemize}
		\item $a(x, a(y, a(z, u))) \rightarrow_{R} a(y, a(z, a(x, u)))$
	\end{itemize}
	And finally we define the goal as:
	\begin{itemize}
		\item $a(b, a(c, a(d, a(e, a(f, a(b, g)))))) \rightarrow_R a(b, a(d, a(c, a(e, a(f, a(b, g))))))$
		    
	\end{itemize}
	
	\noindent The input for {\tt Prover9} will then be:\\
	
	{\tt formulas(assumptions).}
	
	\indent \indent {\tt \% Definition}
	
	\indent \indent	{\tt RR(x, x).}
	
	\indent \indent	{\tt R(x, y) -> R(a(x, z), a(y, z)).}
	
	\indent \indent	{\tt R(x, y) -> R(a(z, x), a(z, y)).}
	
	\indent \indent	{\tt (RR(x, y) \& R(y,z)) -> RR(x, z).}\\
	
	\indent \indent	{\tt \% The given rule}
	
	\indent \indent	{\tt R(a(x, a(y, a(z, u))), a(y, a(z, a(x, u)))).}
	
	{\tt end\_of\_list.}
	
	{\tt formulas(goals).}
	
	\indent \indent {\tt RR(a(b, a(c, a(d, a(e, a(f, a(b, g)))))),}
	
	\indent \indent \indent {\tt a(b, a(d, a(c, a(e, a(f, a(b, g))))))).}
	
	{\tt end\_of\_list.}\\
	\\
	The proof:\\

	{\tt 2 R(x,y) -> R(a(z,x),a(z,y)) \# label(non\_clause).  [assumption].}
	
	{\tt 3 RR(x,y) \& R(y,z) -> RR(x,z) \# label(non\_clause).  [assumption].}
	
	{\tt 4 RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(b,a(d,a(c,a(e,a(f,a(b,g))))))) \# label(non\_clause) \# label(goal).  [goal].}
	
	{\tt 5 R(a(x,a(y,a(z,u))),a(y,a(z,a(x,u)))).  [assumption].}
	
	{\tt 6 RR(x,x).  [assumption].}
	
	{\tt 8 -R(x,y) | R(a(z,x),a(z,y)).  [clausify(2)].}
	
	{\tt 9 -RR(x,y) | -R(y,z) | RR(x,z).  [clausify(3)].}
	
	{\tt 10 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(b,a(d,a(c,a(e,a(f,a(b,g))))))).  [deny(4)].}
	
	{\tt 12 R(a(x,a(y,a(z,a(u,w)))),a(x,a(z,a(u,a(y,w))))).  [ur(8,a,5,a)].}
	
	{\tt 13 RR(a(x,a(y,a(z,u))),a(y,a(z,a(x,u)))).  [ur(9,a,6,a,b,5,a)].}
	
	{\tt 15 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(c,a(b,a(d,a(e,a(f,a(b,g))))))).  [ur(9,b,5,a,c,10,a)].}
	
	{\tt 21 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(d,a(c,a(b,a(e,a(f,a(b,g))))))).  [ur(9,b,5,a,c,15,a)].}
	
	{\tt 36 RR(a(x,a(y,a(z,a(u,w)))),a(y,a(x,a(u,a(z,w))))).  [ur(9,a,13,a,b,12,a)].}
	
	{\tt 38 R(a(x,a(y,a(z,a(u,a(w,v5))))),a(x,a(y,a(u,a(w,a(z,v5)))))).  [ur(8,a,12,a)].}
	
	{\tt 40 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(d,a(e,a(c,a(b,a(f,a(b,g))))))).  [ur(9,b,12,a,c,21,a)].}
	
	{\tt 116 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(c,a(d,a(e,a(b,a(f,a(b,g))))))).  [ur(9,b,5,a,c,40,a)].}
	
	{\tt 164 RR(a(x,a(y,a(z,a(u,a(w,v5))))),a(y,a(x,a(z,a(w,a(u,v5)))))).  [ur(9,a,36,a,b,38,a)].}
	
	{\tt 170 R(a(x,a(y,a(z,a(u,a(w,a(v5,v6)))))),a(x,a(y,a(z,a(w,a(v5,a(u,v6))))))).  [ur(8,a,38,a)].}
	
	{\tt 319 RR(a(x,a(y,a(z,a(u,a(w,v5))))),a(y,a(z,a(w,a(x,a(u,v5)))))).  [ur(9,a,164,a,b,12,a)].}
	
	{\tt 800 -RR(a(b,a(c,a(d,a(e,a(f,a(b,g)))))),a(c,a(d,a(f,a(e,a(b,a(b,g))))))).  [ur(9,b,38,a,c,116,a)].}
	
	{\tt 1604 RR(a(x,a(y,a(z,a(u,a(w,a(v5,v6)))))),a(y,a(z,a(w,a(u,a(v5,a(x,v6))))))).  [ur(9,a,319,a,b,170,a)].}
	
	{\tt 1605 \$F.  [resolve(1604,a,800,a)].}
	
	

\end{document}